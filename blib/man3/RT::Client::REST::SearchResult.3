.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RT::Client::REST::SearchResult 3"
.TH RT::Client::REST::SearchResult 3 "2007-12-23" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
RT::Client::REST::SearchResult \-\- Search results representation.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  my $iterator = $search->get_iterator;
\&  my $count = $iterator->count;
.Ve
.PP
.Vb 3
\&  while (defined(my $obj = &$iterator)) {
\&    # do something with the $obj
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is a representation of a search result.  This is the type
of the object you get back when you call method \f(CW\*(C`search()\*(C'\fR on
RT::Client::REST::Object\-derived objects.  It makes it easy to
iterate over results and find out just how many there are.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBcount\fR" 4
.IX Item "count"
Returns the number of search results.  This number will always be the
same unless you stick your fat dirty fingers into the object and abuse
it.  This number is not affected by calls to \f(CW\*(C`get_iterator()\*(C'\fR.
.IP "\fBget_iterator\fR" 4
.IX Item "get_iterator"
Returns a reference to a subroutine which is used to iterate over the
results.
.Sp
Evaluating it in scalar context, returns the next object
or \f(CW\*(C`undef\*(C'\fR if all the results have already been iterated over.  Note
that for each object to be instantiated with correct values,
\&\fB\f(BIretrieve()\fB\fR method is called on the object before returning it
to the caller.
.Sp
Evaluating the subroutine reference in list context returns a list
of all results fully instantiated.  \s-1WARNING:\s0 this may be expensive,
as each object is issued \fB\f(BIretrieve()\fB\fR method.  Subsequent calls to
the iterator result in empty list.
.Sp
You may safely mix calling the iterator in scalar and list context.  For
example:
.Sp
.Vb 1
\&  $iterator = $search->get_iterator;
.Ve
.Sp
.Vb 3
\&  $first = &$iterator;
\&  $second = &$iterator;
\&  @the_rest = &$iterator;
.Ve
.Sp
You can get as many iterators as you want \*(-- they will not step on
each other's toes.
.IP "\fBnew\fR" 4
.IX Item "new"
You should not have to call it yourself, but just for the sake of
completeness, here are the arguments:
.Sp
.Vb 9
\&  my $search = RT::Client::REST::SearchResult->new(
\&    ids => [1 .. 10],
\&    object => sub {       # Yup, that's a closure.
\&      RT::Client::REST::Ticket->new(
\&        id => shift,
\&        rt => $rt,
\&      );
\&    },
\&  );
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
RT::Client::REST::Object, RT::Client::REST.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dmitri Tikhonov <dtikhonov@yahoo.com>
